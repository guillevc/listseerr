import { useState, useEffect, useRef } from 'react';
import { Plus } from 'lucide-react';
import type { ProviderType } from 'shared/domain/types';
import {
  TraktChartTypeValues,
  TraktMediaTypeValues,
  type TraktChartType,
  type TraktMediaType,
} from 'shared/domain/types';
import {
  getProviderDisplayName,
  isTrakt,
  isTraktChart,
  isMdbList,
  isStevenLu,
  isAnilist,
} from 'shared/domain/logic';
import { getTraktChartDisplayName } from 'shared/domain/logic';
import {
  listNameSchema,
  maxItemsSchema,
  anilistUsernameSchema,
  anilistStatusDisplayNames,
  AnilistStatusValues,
  type AnilistStatus,
} from 'shared/presentation/schemas';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '../ui/dialog';
import { Button } from '../ui/button';
import { validateAndDetectProvider, getProviderName } from '../../lib/url-validator';
import { useToast } from '../../hooks/use-toast';
import { useMinLoading } from '../../hooks/use-min-loading';
import { useProviderConfig } from '../../hooks/use-provider-config';
import { trpc } from '../../lib/trpc';
import { showErrorToast, showValidationErrorToast } from '../../lib/toast-helpers';
import { StepProviderSelection, StepListConfiguration } from './add-list';

export function AddListDialog() {
  const [open, setOpen] = useState(false);
  const [name, setName] = useState('');
  const [url, setUrl] = useState('');
  const [maxItems, setMaxItems] = useState('20');
  const [provider, setProvider] = useState<ProviderType>('trakt');
  const [urlError, setUrlError] = useState<string | null>(null);
  const [selectedMediaType, setSelectedMediaType] = useState<TraktMediaType>(
    TraktMediaTypeValues.MOVIES
  );
  const [selectedChartType, setSelectedChartType] = useState<TraktChartType>(
    TraktChartTypeValues.TRENDING
  );
  // AniList-specific state
  const [anilistUsername, setAnilistUsername] = useState('');
  const [anilistUsernameError, setAnilistUsernameError] = useState<string | null>(null);
  const [anilistStatus, setAnilistStatus] = useState<AnilistStatus>(AnilistStatusValues.PLANNING);
  const [userEditedName, setUserEditedName] = useState(false);
  const [currentStep, setCurrentStep] = useState<1 | 2>(1);
  const [progressAnimated, setProgressAnimated] = useState(false);
  const { toast } = useToast();

  // Refs for timeout cleanup
  const progressTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const toastTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // Cleanup timeouts on unmount
  useEffect(() => {
    return () => {
      if (progressTimeoutRef.current) clearTimeout(progressTimeoutRef.current);
      if (toastTimeoutRef.current) clearTimeout(toastTimeoutRef.current);
    };
  }, []);

  const utils = trpc.useUtils();
  const { isProviderConfigured } = useProviderConfig();

  const createMutation = trpc.lists.create.useMutation({
    onSuccess: (result) => {
      const newList = result.list;

      // Invalidate all related queries
      void utils.lists.getAll.invalidate();
      void utils.dashboard.getStats.invalidate();

      // Only show success toast if the list is enabled
      // If disabled, the manual toast below will handle it
      if (newList.enabled) {
        toast({
          title: 'List Added',
          description: `${newList.name} has been added successfully`,
        });
      }

      setName('');
      setUrl('');
      setMaxItems('20');
      setUrlError(null);
      setUserEditedName(false);
      setAnilistUsername('');
      setAnilistStatus(AnilistStatusValues.PLANNING);
      setCurrentStep(1);
      setOpen(false);
    },
    onError: (error) => {
      showErrorToast(toast, error);
    },
  });
  const isCreating = useMinLoading(createMutation.isPending);

  // Auto-generate name for traktChart, stevenlu, and anilist
  // For traktChart, always regenerate when media/chart type changes
  // For stevenlu, only regenerate if user hasn't manually edited
  // For anilist, regenerate based on username and status
  const autoGeneratedName = (() => {
    if (isTraktChart(provider)) {
      const chartLabel = getTraktChartDisplayName(selectedChartType);
      const mediaLabel = selectedMediaType === TraktMediaTypeValues.MOVIES ? 'Movies' : 'Shows';
      return `${chartLabel} ${mediaLabel} ${getProviderDisplayName(provider)}`;
    } else if (isStevenLu(provider)) {
      return `${getProviderDisplayName(provider)} Popular Movies`;
    } else if (isAnilist(provider) && anilistUsername) {
      const statusLabel = anilistStatusDisplayNames[anilistStatus];
      return `${anilistUsername}'s ${statusLabel}`;
    }
    return '';
  })();

  // Use auto-generated name unless user has manually edited
  const effectiveName = userEditedName ? name : autoGeneratedName || name;

  const handleUrlChange = (value: string) => {
    setUrl(value);
    if (value) {
      const result = validateAndDetectProvider(value);
      if (!result.isValid || result.provider !== provider) {
        setUrlError(`Please enter a valid ${getProviderDisplayName(provider)} URL`);
      } else {
        setUrlError(null);
      }
    } else {
      setUrlError(null);
    }
  };

  const handleAnilistUsernameChange = (value: string) => {
    setAnilistUsername(value);
    if (value) {
      const result = anilistUsernameSchema.safeParse(value);
      setAnilistUsernameError(
        result.success ? null : (result.error.issues[0]?.message ?? 'Invalid username')
      );
    } else {
      setAnilistUsernameError(null);
    }
  };

  const handleProviderChange = (newProvider: ProviderType) => {
    setProvider(newProvider);
    setUserEditedName(false); // Reset edit flag when provider changes
    // Re-validate URL if one exists (only for trakt and mdblist)
    if (!isTraktChart(newProvider) && !isStevenLu(newProvider) && !isAnilist(newProvider) && url) {
      const result = validateAndDetectProvider(url);
      if (!result.isValid || result.provider !== newProvider) {
        setUrlError(`Please enter a valid ${getProviderDisplayName(newProvider)} URL`);
      } else {
        setUrlError(null);
      }
    } else {
      setUrlError(null);
    }
  };

  const handleOpenChange = (newOpen: boolean) => {
    setOpen(newOpen);
    if (newOpen) {
      // Reset to step 1 when opening dialog
      setCurrentStep(1);
      setName('');
      setUrl('');
      setMaxItems('20');
      setUrlError(null);
      setUserEditedName(false);
      setSelectedMediaType(TraktMediaTypeValues.MOVIES);
      setSelectedChartType(TraktChartTypeValues.TRENDING);
      setAnilistUsername('');
      setAnilistUsernameError(null);
      setAnilistStatus(AnilistStatusValues.PLANNING);
      setProgressAnimated(false);

      // Trigger progress bar animation from 0% to 50%
      if (progressTimeoutRef.current) clearTimeout(progressTimeoutRef.current);
      progressTimeoutRef.current = setTimeout(() => {
        setProgressAnimated(true);
      }, 50);
    }
  };

  const goToStep2 = () => {
    setCurrentStep(2);
    // Trigger auto-name generation when entering step 2
    // For traktChart, always generate name
    // For stevenlu, only generate if user hasn't edited
    // For trakt and mdblist, clear name if user hasn't edited
    // For anilist, name will be auto-generated based on username/status
    if (isTraktChart(provider)) {
      const chartLabel = getTraktChartDisplayName(selectedChartType);
      const mediaLabel = selectedMediaType === TraktMediaTypeValues.MOVIES ? 'Movies' : 'Shows';
      setName(`${chartLabel} ${mediaLabel} ${getProviderDisplayName(provider)}`);
    } else if (isStevenLu(provider) && !userEditedName) {
      setName(`${getProviderDisplayName(provider)} Popular Movies`);
    } else if ((isTrakt(provider) || isMdbList(provider)) && !userEditedName) {
      setName('');
    } else if (isAnilist(provider) && !userEditedName) {
      // AniList name will be auto-generated once username is entered
      setName('');
    }
  };

  const goToStep1 = () => {
    setCurrentStep(1);
    // Clear form data when going back to provider selection
    setName('');
    setUrl('');
    setMaxItems('20');
    setUrlError(null);
    setUserEditedName(false);
    setSelectedMediaType(TraktMediaTypeValues.MOVIES);
    setSelectedChartType(TraktChartTypeValues.TRENDING);
    setAnilistUsername('');
    setAnilistUsernameError(null);
    setAnilistStatus(AnilistStatusValues.PLANNING);
  };

  const handleAdd = () => {
    // Validate name using shared schema
    const nameResult = listNameSchema.safeParse(effectiveName);
    if (!nameResult.success) {
      const firstIssue = nameResult.error.issues[0];
      showValidationErrorToast(toast, firstIssue?.message ?? 'Invalid name');
      return;
    }

    let finalUrl = url;
    let displayUrl: string | null = null;

    // For traktChart, construct the URL from selections
    if (isTraktChart(provider)) {
      finalUrl = `https://trakt.tv/${selectedMediaType}/${selectedChartType}`;
    } else if (isStevenLu(provider)) {
      // For StevenLu, use the API URL internally but display the user-facing URL
      finalUrl = 'https://s3.amazonaws.com/popular-movies/movies.json';
      displayUrl = 'https://movies.stevenlu.com';
    } else if (isAnilist(provider)) {
      // Validate AniList username
      const usernameResult = anilistUsernameSchema.safeParse(anilistUsername);
      if (!usernameResult.success) {
        const firstIssue = usernameResult.error.issues[0];
        showValidationErrorToast(toast, firstIssue?.message ?? 'Invalid AniList username');
        return;
      }
      // Construct AniList URL: anilist:{username}:{status}
      finalUrl = `anilist:${usernameResult.data}:${anilistStatus}`;
    } else {
      // Validate URL for trakt and mdblist
      const result = validateAndDetectProvider(url);
      if (!result.isValid || result.provider !== provider) {
        showValidationErrorToast(
          toast,
          `Please enter a valid ${getProviderDisplayName(provider)} URL`
        );
        return;
      }
    }

    // Check if provider is configured
    const isConfigured = isProviderConfigured(provider);

    // Validate maxItems using shared schema
    const maxItemsNum = parseInt(maxItems);
    const maxItemsResult = maxItemsSchema.safeParse(maxItemsNum);
    if (!maxItemsResult.success) {
      const firstIssue = maxItemsResult.error.issues[0];
      showValidationErrorToast(toast, firstIssue?.message ?? 'Invalid max items');
      return;
    }

    createMutation.mutate({
      name: nameResult.data, // Use validated & trimmed name
      url: finalUrl,
      ...(displayUrl ? { displayUrl } : {}),
      provider: provider,
      enabled: isConfigured,
      maxItems: maxItemsResult.data, // Use validated maxItems
    });

    // Show info message if provider not configured
    if (!isConfigured) {
      if (toastTimeoutRef.current) clearTimeout(toastTimeoutRef.current);
      toastTimeoutRef.current = setTimeout(() => {
        toast({
          title: 'List Added as Disabled',
          description: `The list was added but is disabled because ${getProviderDisplayName(provider)} is not configured. Configure the provider in Settings â†’ API Keys to enable processing.`,
        });
      }, 500);
    }
  };

  return (
    <Dialog open={open} onOpenChange={handleOpenChange} modal={false}>
      <DialogTrigger asChild>
        <Button>
          <Plus className="h-4 w-4" />
          Add List
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-xl">
        {/* Dialog Header - Always Visible */}
        <DialogHeader>
          <DialogTitle>Add New List</DialogTitle>
          <DialogDescription>
            {currentStep === 1
              ? 'Select a provider'
              : `Configure ${getProviderName(provider)} list`}
          </DialogDescription>
        </DialogHeader>

        {/* Animated Progress Bar */}
        <div className="mt-4 h-2 w-full rounded-full bg-card">
          <div
            className="h-full rounded-full bg-primary transition-all duration-500 ease-out"
            style={{
              width: currentStep === 1 ? (progressAnimated ? '50%' : '0%') : '100%',
            }}
          ></div>
        </div>

        {/* STEP 1: Provider Selection */}
        {currentStep === 1 && (
          <StepProviderSelection
            provider={provider}
            onProviderChange={handleProviderChange}
            isProviderConfigured={isProviderConfigured}
            onContinue={goToStep2}
          />
        )}

        {/* STEP 2: Configure Details */}
        {currentStep === 2 && (
          <StepListConfiguration
            provider={provider}
            name={effectiveName}
            onNameChange={(value) => {
              setName(value);
              setUserEditedName(true);
            }}
            url={url}
            onUrlChange={handleUrlChange}
            urlError={urlError}
            maxItems={maxItems}
            onMaxItemsChange={setMaxItems}
            selectedMediaType={selectedMediaType}
            onMediaTypeChange={setSelectedMediaType}
            selectedChartType={selectedChartType}
            onChartTypeChange={setSelectedChartType}
            anilistUsername={anilistUsername}
            onAnilistUsernameChange={handleAnilistUsernameChange}
            anilistUsernameError={anilistUsernameError}
            anilistStatus={anilistStatus}
            onAnilistStatusChange={setAnilistStatus}
            onBack={goToStep1}
            onSubmit={handleAdd}
            isLoading={isCreating}
          />
        )}
      </DialogContent>
    </Dialog>
  );
}
